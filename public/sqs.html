<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LocalStack SQS Explorer</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
      }
      #sidebar {
        position: relative;
        width: 400px;
        min-width: 180px;
        max-width: 600px;
        background: #f8fafc;
        overflow: auto;
        border-right: 1px solid #e2e8f0;
        box-shadow: 2px 0 4px rgba(0, 0, 0, 0.05);
      }

      /* Sidebar resizer */
      #resizer {
        width: 5px;
        cursor: col-resize;
        background: transparent;
      }
      #resizer:hover {
        background: rgba(0,0,0,0.1);
      }
      #content {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
      }
      .queue {
        padding: 10px 12px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 4px 6px;
        border-radius: 6px;
        transition: background 0.15s, color 0.15s;
      }
      .queue:hover {
        background: #e5e7eb;
      }
      .queue.active {
        background: #2563eb;
        color: #ffffff;
      }
      pre {
        background: #eee;
        padding: 10px;
      }
      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: #ffffff;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      th,
      td {
        border: none;
        padding: 12px 16px;
      }
      th {
        background: #f3f4f6;
        text-align: left;
        font-weight: 600;
      }
      tbody tr:not(:last-child) td {
        border-bottom: 1px solid #e5e7eb; /* light divider */
      }
      td.readonly {
        background: #f9f9f9;
      }

      /* Stat card */
      .stat-card {
        display: inline-block;
        background: #f3f4f6;
        padding: 8px 14px;
        border-radius: 8px;
        margin: 0 8px 16px 0;
        font-size: 14px;
        font-weight: 600;
      }

      /* Loader overlay */
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        display: none;
      }
      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Toast */
      #toast {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #4caf50;
        color: white;
        padding: 10px 20px;
        border-radius: 4px;
        display: none;
        z-index: 1100;
      }

      /* Buttons */
      .action-btn {
        padding: 6px 14px;
        font-size: 14px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
      }
      .action-btn.primary {
        background: #1d4ed8;
        color: #fff;
      }
      .action-btn.primary:hover {
        background: #2563eb;
      }
      .action-btn.secondary {
        background: #e5e7eb;
        color: #111827;
      }
      .action-btn.secondary:hover {
        background: #d1d5db;
      }
      .count-badge {
        background: #e5e7eb;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        min-width: 36px;
        text-align: center;
      }
      .queue.active .count-badge {
        background: rgba(255, 255, 255, 0.3);
        color: #ffffff;
      }

      .queue-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        font-weight: 600;
        padding: 6px 12px 4px 12px;
        color: #475569; /* slate-600 */
        margin: 4px 6px 0 6px;
        border-bottom: 1px solid #e2e8f0;
      }

      /* Search input tweaks */
      #search {
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        outline: none;
      }
      #search:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <h2 style="padding: 10px; margin: 0;">Queues</h2>
      <input
        id="search"
        type="text"
        placeholder="Search..."
        style="width: 90%; margin: 10px; padding: 6px;"
      />
      <div id="queueHeader" class="queue-header">
        <span>Queue</span>
        <span>Avail / Inflight</span>
      </div>
      <div id="queues"></div>
    </div>
    <div id="resizer"></div>
    <div id="content">
      <h2 id="queueTitle" style="margin:0 0 10px 0; display:none;"></h2>

      <h2 style="display: flex; align-items: center; gap: 10px;">
        <span>Attributes</span>
        <button id="editBtn" class="action-btn primary" style="display: none;">Edit</button>
        <button id="saveBtn" class="action-btn primary" style="display: none;">Save</button>
        <button id="cancelBtn" class="action-btn secondary" style="display: none;">Cancel</button>
        <button id="sendMsgBtn" class="action-btn primary" style="display: none;">Send Message</button>
      </h2>
      <div id="messageStats" style="display:none;"></div>
      <div id="attributesPlaceholder">Select a queue to view its attributes</div>
      <table id="attributesTable" style="display: none;">
        <thead>
          <tr>
            <th>Attribute</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Send Message Modal -->
    <div id="sendMsgModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.2); z-index:2000; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:24px 28px; border-radius:10px; min-width:320px; max-width:90vw; box-shadow:0 2px 16px rgba(0,0,0,0.15); display:flex; flex-direction:column; gap:16px;">
        <h3 style="margin:0 0 8px 0;">Send Message</h3>
        <textarea id="sendMsgInput" rows="6" style="width:100%; resize:vertical; font-size:15px; padding:8px;"></textarea>
        <div id="msgGroupIdRow" style="display:none; flex-direction:column; gap:4px;">
          <label for="sendMsgGroupId" style="font-size:14px;">Message Group ID <span style="color:#e11d48;">*</span></label>
          <input id="sendMsgGroupId" type="text" style="width:100%; font-size:15px; padding:6px; border-radius:6px; border:1px solid #cbd5e1;" />
        </div>
        <div id="msgDedupIdRow" style="display:none; flex-direction:column; gap:4px;">
          <label for="sendMsgDedupId" style="font-size:14px;">Message Deduplication ID <span style="color:#e11d48;">*</span></label>
          <input id="sendMsgDedupId" type="text" style="width:100%; font-size:15px; padding:6px; border-radius:6px; border:1px solid #cbd5e1;" placeholder="Leave blank to auto-generate" />
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="sendMsgCancel" class="action-btn secondary">Cancel</button>
          <button id="sendMsgSend" class="action-btn primary">Send</button>
        </div>
      </div>
    </div>

    <!-- Loader & Toast -->
    <div id="loader"><div class="spinner"></div></div>
    <div id="toast">Updated successfully</div>

    <script>
      let allQueues = [];
      let selectedQueueUrl = null;
      let editing = false;
      let queueCounts = {};
      let selectedQueueDeduplication = false; // true if ContentBasedDeduplication is enabled

      // Key for persisting selected queue
      const SELECTED_KEY = 'sqs_selected_queue';

      // List of writable attributes (should match backend)
      const WRITABLE = [
        'DelaySeconds',
        'MaximumMessageSize',
        'MessageRetentionPeriod',
        'Policy',
        'ReceiveMessageWaitTimeSeconds',
        'RedrivePolicy',
        'VisibilityTimeout',
        'KmsMasterKeyId',
        'KmsDataKeyReusePeriodSeconds',
        'ContentBasedDeduplication',
        'FifoThroughputLimit',
        'DeduplicationScope',
        'RedriveAllowPolicy',
        'SqsManagedSseEnabled',
      ];

      function renderQueues(filter = '') {
        const queueContainer = document.getElementById('queues');
        queueContainer.innerHTML = '';
        const lowerFilter = filter.toLowerCase();

        allQueues
          .filter((url) =>
            url.toLowerCase().includes(lowerFilter)
          )
          .forEach((url) => {
            const name = url.split('/').pop();
            const div = document.createElement('div');
            div.className = 'queue';
            div.title = url; // keep full URL in tooltip
            div.onclick = () => loadAttributes(url);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = name;

            const countSpan = document.createElement('span');
            countSpan.className = 'count-badge';
            const counts = queueCounts[url];
            countSpan.textContent = counts
              ? `${counts.avail ?? '-'} / ${counts.inflight ?? '-'}`
              : '-';

            div.appendChild(nameSpan);
            div.appendChild(countSpan);
            queueContainer.appendChild(div);

            if (url === selectedQueueUrl) {
              div.classList.add('active');
            }
          });
      }

      async function loadQueues() {
        try {
          const res = await fetch('/api/queues');
          const data = await res.json();
          allQueues = data.queues || [];
          const searchVal = document.getElementById('search').value;
          queueCounts = {}; // reset counts on refresh
          renderQueues(searchVal);

          // Fetch message counts in background
          allQueues.forEach(async (url) => {
            try {
              const res = await fetch('/api/queue?url=' + encodeURIComponent(url));
              const data = await res.json();
              const avail = data.attributes?.ApproximateNumberOfMessages ?? '-';
              const inflight = data.attributes?.ApproximateNumberOfMessagesNotVisible ?? '-';
              queueCounts[url] = { avail, inflight };
              // Update badge if element still exists
              const row = Array.from(document.querySelectorAll('.queue')).find((el) => el.title === url);
              if (row) {
                const badge = row.querySelector('.count-badge');
                if (badge) badge.textContent = `${avail} / ${inflight}`;
              }
            } catch (e) {
              console.error('Failed to fetch count for', url, e);
            }
          });

          // After counts loaded you may need to refresh active highlight
          // Restore selected queue if available
          const savedQueue = localStorage.getItem(SELECTED_KEY);
          if (savedQueue && allQueues.includes(savedQueue)) {
            // Avoid duplicate calls
            if (selectedQueueUrl !== savedQueue) {
              loadAttributes(savedQueue);
            }
          }
        } catch (e) {
          console.error('Failed to load queues', e);
        }
      }

      // Setup search handler
      document.addEventListener('DOMContentLoaded', () => {
        // Sidebar resizer logic
        const sidebar = document.getElementById('sidebar');
        const resizer = document.getElementById('resizer');
        let startX, startWidth;

        const min = 180;
        const max = 600;

        function onMouseMove(e) {
          const dx = e.clientX - startX;
          let newWidth = startWidth + dx;
          newWidth = Math.max(min, Math.min(max, newWidth));
          sidebar.style.width = newWidth + 'px';
        }

        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          document.body.style.userSelect = '';
        }

        resizer.addEventListener('mousedown', (e) => {
          startX = e.clientX;
          startWidth = sidebar.offsetWidth;
          document.body.style.userSelect = 'none'; // prevent text selection
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });

        const searchInput = document.getElementById('search');

        // Restore previous filter
        const savedFilter = localStorage.getItem('sqs_filter') || '';
        searchInput.value = savedFilter;
        searchInput.addEventListener('input', (e) => {
          const val = e.target.value;
          localStorage.setItem('sqs_filter', val);
          renderQueues(val);
        });
        if (savedFilter) {
          renderQueues(savedFilter);
        }
      });

      async function loadAttributes(url) {
        const res = await fetch('/api/queue?url=' + encodeURIComponent(url));
        const data = await res.json();

        // Set title
        const titleEl = document.getElementById('queueTitle');
        titleEl.textContent = url.split('/').pop();
        titleEl.style.display = 'block';

        selectedQueueUrl = url;
        selectedQueueDeduplication = data.attributes?.ContentBasedDeduplication === 'true';

        // Persist selection
        localStorage.setItem(SELECTED_KEY, url);
        editing = false;

        // Update active highlight
        document.querySelectorAll('.queue.active').forEach((el) => el.classList.remove('active'));
        const activeRow = Array.from(document.querySelectorAll('.queue')).find((el) => el.title === url);
        if (activeRow) activeRow.classList.add('active');

        // Button visibility
        document.getElementById('editBtn').style.display = 'inline-block';
        document.getElementById('saveBtn').style.display = 'none';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('sendMsgBtn').style.display = 'inline-block';

        // Restore details rendering
        const placeholder = document.getElementById('attributesPlaceholder');
        const statsDiv = document.getElementById('messageStats');
        const table = document.getElementById('attributesTable');
        const tbody = table.querySelector('tbody');

        // Clear previous rows
        tbody.innerHTML = '';

        // Message stats
        const avail = data.attributes?.ApproximateNumberOfMessages;
        const inflight = data.attributes?.ApproximateNumberOfMessagesNotVisible;
        if (avail !== undefined || inflight !== undefined) {
          statsDiv.innerHTML = `
            <span class="stat-card">Available: ${avail ?? '-'}</span>
            <span class="stat-card">In flight: ${inflight ?? '-'}</span>`;
          statsDiv.style.display = 'block';
        } else {
          statsDiv.style.display = 'none';
        }

        // Populate new rows
        Object.entries(data.attributes || {}).forEach(([key, value]) => {
          const tr = document.createElement('tr');
          const tdKey = document.createElement('td');
          tdKey.textContent = key;
          const tdValue = document.createElement('td');
          tdValue.textContent = value;
          if (!WRITABLE.includes(key)) {
            tdValue.classList.add('readonly');
          }
          tr.appendChild(tdKey);
          tr.appendChild(tdValue);
          tbody.appendChild(tr);
        });

        // Toggle visibility
        placeholder.style.display = 'none';
        table.style.display = 'table';
      }

      // Toggle to edit mode
      function enterEditMode() {
        if (!selectedQueueUrl || editing) return;
        editing = true;

        const table = document.getElementById('attributesTable');
        const tbody = table.querySelector('tbody');

        Array.from(tbody.rows).forEach((row) => {
          const key = row.cells[0].textContent;
          const valueCell = row.cells[1];

          if (!WRITABLE.includes(key)) return; // skip read-only

          const input = document.createElement('input');
          input.type = 'text';
          input.value = valueCell.textContent;
          input.style.width = '100%';
          valueCell.textContent = '';
          valueCell.appendChild(input);
        });

        // Buttons
        document.getElementById('editBtn').style.display = 'none';
        document.getElementById('saveBtn').style.display = 'inline-block';
        document.getElementById('cancelBtn').style.display = 'inline-block';
      }

      // Cancel editing (reload attributes)
      function cancelEdit() {
        if (!editing) return;
        loadAttributes(selectedQueueUrl);
      }

      // Hide title when no queue selected initially
      document.getElementById('queueTitle').style.display = 'none';

      // Save edited attributes
      async function saveEdit() {
        if (!editing) return;

        const table = document.getElementById('attributesTable');
        const tbody = table.querySelector('tbody');
        const attributes = {};
        Array.from(tbody.rows).forEach((row) => {
          const key = row.cells[0].textContent;
          const input = row.cells[1].querySelector('input');
          if (input) {
            attributes[key] = input.value;
          }
        });

        // Show loader
        document.getElementById('loader').style.display = 'flex';

        try {
          await fetch('/api/queue/attributes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: selectedQueueUrl, attributes }),
          });

          // Hide loader & toast success
          document.getElementById('loader').style.display = 'none';
          showToast('Attributes updated successfully');

          // Reload attributes to view mode
          loadAttributes(selectedQueueUrl);
        } catch (e) {
          console.error('Failed to update attributes', e);
          document.getElementById('loader').style.display = 'none';
          alert('Failed to update attributes: ' + e.message);
        }
      }

      // Toast helper
      function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.style.display = 'block';
        setTimeout(() => {
          toast.style.display = 'none';
        }, 3000);
      }

      // Hook up buttons
      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('editBtn').addEventListener('click', enterEditMode);
        document.getElementById('saveBtn').addEventListener('click', saveEdit);
        document.getElementById('cancelBtn').addEventListener('click', cancelEdit);
        document.getElementById('sendMsgBtn').addEventListener('click', () => {
          document.getElementById('sendMsgInput').value = '';
          document.getElementById('sendMsgGroupId').value = '';
          document.getElementById('sendMsgDedupId').value = '';
          // Show MessageGroupId input if FIFO
          if (selectedQueueUrl && selectedQueueUrl.endsWith('.fifo')) {
            document.getElementById('msgGroupIdRow').style.display = 'flex';
            // Show deduplication ID if ContentBasedDeduplication is not enabled
            if (!selectedQueueDeduplication) {
              document.getElementById('msgDedupIdRow').style.display = 'flex';
            } else {
              document.getElementById('msgDedupIdRow').style.display = 'none';
            }
          } else {
            document.getElementById('msgGroupIdRow').style.display = 'none';
            document.getElementById('msgDedupIdRow').style.display = 'none';
          }
          document.getElementById('sendMsgModal').style.display = 'flex';
        });
        document.getElementById('sendMsgCancel').addEventListener('click', () => {
          document.getElementById('sendMsgModal').style.display = 'none';
        });
        document.getElementById('sendMsgSend').addEventListener('click', async () => {
          const msg = document.getElementById('sendMsgInput').value;
          const groupId = document.getElementById('sendMsgGroupId').value;
          let dedupId = document.getElementById('sendMsgDedupId').value;
          const isFifo = selectedQueueUrl && selectedQueueUrl.endsWith('.fifo');
          const needsDedup = isFifo && !selectedQueueDeduplication;
          if (!msg.trim()) {
            alert('Message cannot be empty!');
            return;
          }
          if (isFifo && !groupId.trim()) {
            alert('Message Group ID is required for FIFO queues!');
            return;
          }
          if (needsDedup && !dedupId.trim()) {
            // Auto-generate a deduplication ID if not provided
            dedupId = 'dedup-' + Date.now() + '-' + Math.random().toString(36).slice(2, 10);
          }
          document.getElementById('loader').style.display = 'flex';
          try {
            const res = await fetch('/api/queue/send', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url: selectedQueueUrl, message: msg, messageGroupId: isFifo ? groupId : undefined, messageDeduplicationId: needsDedup ? dedupId : undefined })
            });
            if (!res.ok) throw new Error('Failed to send message');
            document.getElementById('sendMsgModal').style.display = 'none';
            showToast('Message sent!');
            // Optionally refresh queue stats
            loadAttributes(selectedQueueUrl);
          } catch (e) {
            alert('Failed to send message: ' + e.message);
          } finally {
            document.getElementById('loader').style.display = 'none';
          }
        });
      });

      loadQueues();
      // Refresh queue list every 30 seconds in case new queues appear
      setInterval(loadQueues, 30000);
    </script>
  </body>
</html> 